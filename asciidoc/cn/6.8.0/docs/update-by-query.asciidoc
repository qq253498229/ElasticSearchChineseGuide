[[java-docs-update-by-query]]
=== Update By Query API

`updateByQuery` 最简单的用法是在不更改源的情况下更新同一个index中的所有文档。
这种用法还可以获取新的属性或其它网络映射的改变。

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source("source_index").abortOnVersionConflict(false);
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

调用 `updateByQuery` 方法会优先获取index的快照，然后使用`internal`版本索引所有的文档。

NOTE: 当文档正在建立索引时，如果快照版本发生了改变，那么这个文档的版本会发生冲突。

当版本匹配时， `updateByQuery` 方法会更新文档并增加版本号。

所有的修改和查询都失败的时候， `updateByQuery` 方法就会停止。
这些失败的原因可以从 `BulkByScrollResponse#getIndexingFailures` 中获得。
但是所有成功的更新操作都会保留并且不会回滚。当第一次发生失败而导致终止时，响应会包含批量请求生成的所有失败消息。

为了防止版本冲突而导致 `updateByQuery` 方法停止，请设置 `abortOnVersionConflict(false)` 。
第一个例子就是这样做的，因为这个例子是想获取网络映射的修改，并且版本冲突意味着冲突文档在 `updateByQuery`
的开始和尝试更新修改文档之间更新。这样很好，因为修改操作会获取更新后的网络映射。

`UpdateByQueryRequestBuilder` API 支持过滤更新后的文档，并且可以限制更新的数量，还可以通过脚本更新文档:

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source("source_index")
    .filter(QueryBuilders.termQuery("level", "awesome"))
    .size(1000)
    .script(new Script(ScriptType.INLINE,
        "ctx._source.awesome = 'absolutely'",
        "painless",
        Collections.emptyMap()));
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

`UpdateByQueryRequestBuilder` 还支持直接获取用于查询文档的语句。
你可以用它来改变默认的滚动数量，或者修改匹配文档的请求。

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source("source_index")
    .source()
    .setSize(500);
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

您还可以将 `size` 和排序结合使用，来限制需要更新的文档:

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source("source_index")
    .size(100)
    .source()
    .addSort("cat", SortOrder.DESC);
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

除了修改文档的 `_source` 字段之外，您还可以使用脚本来做其它操作，比如 Update API:

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source("source_index")
    .script(new Script(
        ScriptType.INLINE,
        "if (ctx._source.awesome == 'absolutely') {"
            + "  ctx.op='noop'"
            + "} else if (ctx._source.awesome == 'lame') {"
            + "  ctx.op='delete'"
            + "} else {"
            + "ctx._source.awesome = 'absolutely'}",
        "painless",
        Collections.emptyMap()));
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

与 <<java-docs-update,Update API>> 一样，您可以通过设置 `ctx.op` 来改变执行的操作:

`noop`::

如果这个脚本不会修改任何文档，可以设置 `ctx.op = "noop"` 。
`updateByQuery` 操作会从修改中忽略掉这个文档。
这个行为会让响应体中的 `noop` 计数器增加。

`delete`::

如果这个脚本一定会删除文档，可以设置 `ctx.op = "delete"` 。 这样在响应体中的 `deleted` 计数器会有显示。

`ctx.op` 设置其它值会报错。 `ctx` 设置其它字段也会报错。

这个API不允许移动它能接触到的文档，只允许修改source。这是故意这样设计的！我们规定不允许从原始位置将文档移除。

你也可以一次在多个索引和类型上执行这些操作，类似于 search API :

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source("foo", "bar").source().setTypes("a", "b");
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

如果你提供了 `routing` 值，则该进程会将路由值复制到滚动查询中，从而将进程限制为匹配该路由值的分片:

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.source().setRouting("cat");
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

`updateByQuery` 也可以通过指定一个像这样的 `pipeline` 来使用 ingest 节点:

["source","java"]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery =
  UpdateByQueryAction.INSTANCE.newRequestBuilder(client);
updateByQuery.setPipeline("hurray");
BulkByScrollResponse response = updateByQuery.get();
--------------------------------------------------

[float]
[[java-docs-update-by-query-task-api]]
=== Works with the Task API

You can fetch the status of all running update-by-query requests with the Task API:

["source","java",subs="attributes,callouts,macros"]
--------------------------------------------------
include-tagged::{client-reindex-tests}/ReindexDocumentationIT.java[update-by-query-list-tasks]
--------------------------------------------------

With the `TaskId` shown above you can look up the task directly:

// provide API Example
["source","java",subs="attributes,callouts,macros"]
--------------------------------------------------
include-tagged::{client-reindex-tests}/ReindexDocumentationIT.java[update-by-query-get-task]
--------------------------------------------------

[float]
[[java-docs-update-by-query-cancel-task-api]]
=== Works with the Cancel Task API

Any Update By Query can be canceled using the Task Cancel API:

["source","java",subs="attributes,callouts,macros"]
--------------------------------------------------
include-tagged::{client-reindex-tests}/ReindexDocumentationIT.java[update-by-query-cancel-task]
--------------------------------------------------

Use the `list tasks` API to find the value of `taskId`.

Cancelling a request is typically a very fast process but can take up to a few seconds.
The task status API continues to list the task until the cancellation is complete.

[float]
[[java-docs-update-by-query-rethrottle]]
=== Rethrottling

Use the `_rethrottle` API to change the value of `requests_per_second` on a running update:

["source","java",subs="attributes,callouts,macros"]
--------------------------------------------------
include-tagged::{client-reindex-tests}/ReindexDocumentationIT.java[update-by-query-rethrottle]
--------------------------------------------------

Use the `list tasks` API to find the value of `taskId`.

As with the `updateByQuery` API, the value of `requests_per_second`
can be any positive float value to set the level of the throttle, or `Float.POSITIVE_INFINITY` to disable throttling.
A value of `requests_per_second` that speeds up the process takes
effect immediately. `requests_per_second` values that slow the query take effect
after completing the current batch in order to prevent scroll timeouts.
